<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Mesh å¤šäººè§†é¢‘ä¼šè®®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Arial, sans-serif;
        }
        
        body {
            background-color: #1e1e1e;
            color: #fff;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .title {
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .camera-icon {
            font-size: 24px;
        }
        
        .server-url {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }
        
        .url-input {
            padding: 8px 12px;
            width: 300px;
            border-radius: 4px 0 0 4px;
            border: none;
        }
        
        .connect-btn {
            padding: 8px 15px;
            background-color: #09f;
            color: white;
            border: none;
            border-radius: 0 4px 4px 0;
            cursor: pointer;
        }
        
        /* ä¿®å¤ï¼šä¼˜åŒ–çŠ¶æ€æç¤ºæ¡†æ ·å¼ï¼Œç¡®ä¿æ–‡å­—å¯è§ */
        .status-bar {
            padding: 12px 15px;
            border-radius: 6px;
            text-align: center;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            background-color: #2ecc71; /* é»˜è®¤æˆåŠŸè‰² */
            color: #ffffff; /* å¼ºåˆ¶ç™½è‰²æ–‡å­— */
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: relative;
        }
        
        /* é”™è¯¯çŠ¶æ€ - è°ƒæ•´èƒŒæ™¯è‰²ä¸ºæ·±çº¢è‰²ï¼Œä¿è¯æ–‡å­—å¯¹æ¯”åº¦ */
        .status-bar.error {
            background-color: #c0392b !important; 
            color: #ffffff !important; /* å¼ºåˆ¶ç™½è‰²æ–‡å­— */
        }
        
        /* ä¿¡æ¯çŠ¶æ€ - å¤©è“è‰²èƒŒæ™¯ */
        .status-bar.info {
            background-color: #3498db;
            color: #ffffff;
        }
        
        /* å…³é—­æŒ‰é’® */
        .status-bar .close-btn {
            position: absolute;
            top: 50%;
            right: 15px;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            cursor: pointer;
            opacity: 0.8;
        }
        
        .status-bar .close-btn:hover {
            opacity: 1;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .control-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.3s ease;
        }
        
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .start-btn {
            background-color: #2ecc71;
            color: white;
        }
        
        .join-btn {
            background-color: #f39c12;
            color: white;
        }
        
        .leave-btn {
            background-color: #e74c3c;
            color: white;
        }
        
        .participants-panel {
            margin-bottom: 20px;
        }
        
        .panel-header {
            padding: 10px 15px;
            background-color: #2c3e50;
            border-radius: 4px 4px 0 0;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .participant-list {
            max-height: 120px;
            overflow-y: auto;
            padding: 0 15px;
            background-color: #2c3e50;
            border-radius: 0 0 4px 4px;
        }
        
        .participant-item {
            padding: 6px 0;
            border-bottom: 1px solid #34495e;
        }
        
        .current-participant {
            background-color: #27ae60;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 5px 0;
        }
        
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            grid-gap: 15px;
            margin-bottom: 20px;
        }
        
        .video-container {
            position: relative;
            background-color: #2c3e50;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 16/9;
            height: 0;
            padding-bottom: 56.25%;
        }
        
        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .no-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #2c3e50;
            color: #aaa;
        }
        
        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .connection-info {
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 4px;
        }
        
        .info-item {
            margin-bottom: 8px;
        }
        
        .info-label {
            font-weight: bold;
            margin-right: 8px;
        }
        
        .local-tag { background-color: #27ae60; }
        .participant-tag-1 { background-color: #3498db; }
        .participant-tag-2 { background-color: #9b59b6; }
        .participant-tag-3 { background-color: #e67e22; }
        
        .error {
            color: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">ğŸ¥ WebRTC Mesh å¤šäººè§†é¢‘ä¼šè®®</div>
    </div>
    
    <div class="server-url">
        <input type="text" id="serverUrl" class="url-input" value="http://localhost:8081">
        <button id="connectBtn" class="connect-btn">è¿æ¥</button>
    </div>
    
    <!-- ä¿®å¤ï¼šæ·»åŠ å…³é—­æŒ‰é’®ï¼Œä¼˜åŒ–æ ·å¼ -->
    <div class="status-bar" id="statusBar">
        æœªè¿æ¥
        <span class="close-btn" id="statusCloseBtn" onclick="this.parentElement.textContent=''; this.parentElement.className='status-bar'">âœ•</span>
    </div>
    
    <div class="controls">
        <button id="startCameraBtn" class="control-btn start-btn" disabled>å¼€å¯æ‘„åƒå¤´</button>
        <button id="joinMeetingBtn" class="control-btn join-btn" disabled>åŠ å…¥ä¼šè®®</button>
        <button id="leaveMeetingBtn" class="control-btn leave-btn" disabled>ç¦»å¼€ä¼šè®®</button>
    </div>
    
    <div class="participants-panel">
        <div class="panel-header">å‚ä¼šäººå‘˜ (<span id="participantCount">0</span>/4)</div>
        <div class="participant-list" id="participantList"></div>
    </div>
    
    <div class="video-grid" id="videoGrid"></div>
    
    <div class="connection-info">
        <div class="info-item"><span class="info-label">æˆ‘çš„ID:</span> <span id="myId">æœªè¿æ¥</span></div>
        <div class="info-item"><span class="info-label">ä¼šè®®çŠ¶æ€:</span> <span id="meetingStatus">æœªåŠ å…¥</span></div>
        <div class="info-item"><span class="info-label">è¿æ¥çŠ¶æ€:</span> <span id="connectionStatus">æœªè¿æ¥</span></div>
    </div>

    <script>
        // DOMå…ƒç´ 
        const connectBtn = document.getElementById('connectBtn');
        const serverUrlInput = document.getElementById('serverUrl');
        const statusBar = document.getElementById('statusBar');
        const startCameraBtn = document.getElementById('startCameraBtn');
        const joinMeetingBtn = document.getElementById('joinMeetingBtn');
        const leaveMeetingBtn = document.getElementById('leaveMeetingBtn');
        const videoGrid = document.getElementById('videoGrid');
        const participantCount = document.getElementById('participantCount');
        const participantList = document.getElementById('participantList');
        const myIdElement = document.getElementById('myId');
        const meetingStatusElement = document.getElementById('meetingStatus');
        const connectionStatusElement = document.getElementById('connectionStatus');
      
        // æ ¸å¿ƒçŠ¶æ€
        let ws = null;
        let myStream = null;
        let myId = null;
        let isCameraOn = false;
        let isInMeeting = false;
        let members = new Set(); // ä¼šè®®æˆå‘˜é›†åˆ
        let connections = new Map(); // å¯¹ç­‰è¿æ¥
        
        // æ–°å¢ï¼šè·Ÿè¸ªè¿æ¥å»ºç«‹çŠ¶æ€
        let connectionCheckTimer = null;
        let pendingConnections = new Set(); // ç­‰å¾…å»ºç«‹çš„è¿æ¥
      
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        connectBtn.addEventListener('click', connectToServer);
        startCameraBtn.addEventListener('click', toggleCamera);
        joinMeetingBtn.addEventListener('click', joinMeeting);
        leaveMeetingBtn.addEventListener('click', leaveMeeting);
      
        // è¿æ¥æœåŠ¡å™¨
        function connectToServer() {
          if (connectBtn.disabled) return;
          
          const url = serverUrlInput.value.trim();
          const wsUrl = url.replace('http://', 'ws://').replace('https://', 'wss://');
          
          updateStatus(`æ­£åœ¨è¿æ¥æœåŠ¡å™¨...`, 'info');
          connectBtn.disabled = true;
          
          // æ¸…ç†æ—§è¿æ¥
          if (ws) ws.close();
          
          ws = new WebSocket(wsUrl);
          
          ws.onopen = () => {
            updateStatus('âœ… å·²è¿æ¥æœåŠ¡å™¨', 'success');
            connectionStatusElement.textContent = 'å·²è¿æ¥';
            startCameraBtn.disabled = false;
            joinMeetingBtn.disabled = false;
            connectBtn.disabled = false;
          };
          
          ws.onmessage = (e) => {
            try {
              const msg = JSON.parse(e.data);
              handleMessage(msg);
            } catch (err) {
              console.error('æ¶ˆæ¯è§£æå¤±è´¥:', err);
            }
          };
          
          ws.onclose = () => {
            updateStatus('âŒ ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥', 'error');
            connectionStatusElement.textContent = 'å·²æ–­å¼€';
            connectBtn.disabled = false;
            resetState();
          };
          
          ws.onerror = (err) => {
            console.error('è¿æ¥é”™è¯¯:', err);
            updateStatus('âŒ è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥æœåŠ¡å™¨', 'error');
            connectBtn.disabled = false;
          };
        }
      
        // æ¶ˆæ¯å¤„ç†
        function handleMessage(msg) {
          switch (msg.type) {
            case 'id':
              myId = msg.id;
              myIdElement.textContent = myId;
              break;
              
            case 'members':
              // æ›´æ–°æˆå‘˜åˆ—è¡¨
              const newMembers = new Set(msg.members);
              members = newMembers;
              updateParticipantsUI();
              
              // é‡ç½®è¿æ¥æ£€æŸ¥
              if (connectionCheckTimer) {
                clearTimeout(connectionCheckTimer);
                connectionCheckTimer = null;
              }
              
              // æ¸…ç©ºç­‰å¾…åˆ—è¡¨
              pendingConnections.clear();
              
              // è®¡ç®—éœ€è¦å»ºç«‹çš„è¿æ¥
              const otherMembers = Array.from(members).filter(id => id !== myId);
              otherMembers.forEach(id => {
                if (!connections.has(id)) {
                  pendingConnections.add(id);
                }
              });
              
              // å¦‚æœå·²å¼€å¯æ‘„åƒå¤´ï¼Œå»ºç«‹æ–°è¿æ¥
              if (isCameraOn && isInMeeting) {
                if (otherMembers.length === 0) {
                  // åªæœ‰è‡ªå·±ä¸€ä¸ªäºº
                  updateStatus('âœ… å·²åŠ å…¥ä¼šè®®ï¼ˆå½“å‰åªæœ‰æ‚¨ä¸€äººï¼‰', 'success');
                } else {
                  updateStatus(`æ­£åœ¨å»ºç«‹P2Pè¿æ¥ (${otherMembers.length}ä¸ªè¿æ¥)...`, 'info');
                  establishConnections();
                  
                  // å¯åŠ¨è¿æ¥æ£€æŸ¥è®¡æ—¶å™¨
                  connectionCheckTimer = setTimeout(() => {
                    checkConnectionsStatus();
                  }, 3000);
                }
              }
              break;
              
            case 'user-join':
              if (msg.id !== myId) {
                members.add(msg.id);
                updateParticipantsUI();
                
                // æ·»åŠ åˆ°ç­‰å¾…è¿æ¥åˆ—è¡¨
                pendingConnections.add(msg.id);
                
                if (isCameraOn && isInMeeting) {
                  createPeerConnection(msg.id);
                  updateStatus(`æ­£åœ¨ä¸æ–°æˆå‘˜ ${msg.id} å»ºç«‹è¿æ¥...`, 'info');
                }
              }
              break;
              
            case 'user-leave':
              members.delete(msg.id);
              pendingConnections.delete(msg.id);
              updateParticipantsUI();
              closeConnection(msg.id);
              break;
              
            case 'signal':
              if (msg.from && msg.data) {
                handleSignal(msg.from, msg.data);
              }
              break;
          }
        }
      
        // æ£€æŸ¥è¿æ¥çŠ¶æ€
        function checkConnectionsStatus() {
          const otherMembers = Array.from(members).filter(id => id !== myId);
          
          if (otherMembers.length === 0) {
            updateStatus('âœ… å·²åŠ å…¥ä¼šè®®ï¼ˆå½“å‰åªæœ‰æ‚¨ä¸€äººï¼‰', 'success');
            return;
          }
          
          // è®¡ç®—å·²å»ºç«‹çš„è¿æ¥
          const establishedConnections = otherMembers.filter(id => {
            const pc = connections.get(id);
            return pc && pc.connectionState === 'connected';
          });
          
          if (establishedConnections.length === otherMembers.length) {
            // æ‰€æœ‰è¿æ¥éƒ½å»ºç«‹æˆåŠŸ
            updateStatus(`âœ… ä¼šè®®è¿æ¥å·²å°±ç»ª (${otherMembers.length}ä¸ªP2Pè¿æ¥)`, 'success');
          } else if (establishedConnections.length > 0) {
            // éƒ¨åˆ†è¿æ¥æˆåŠŸ
            updateStatus(`âœ… å·²è¿æ¥ ${establishedConnections.length}/${otherMembers.length} ä¸ªå‚ä¸è€…`, 'info');
          } else {
            // æ²¡æœ‰è¿æ¥æˆåŠŸ
            updateStatus('âš ï¸ æ­£åœ¨å°è¯•å»ºç«‹P2Pè¿æ¥...', 'info');
            
            // é‡æ–°æ£€æŸ¥
            connectionCheckTimer = setTimeout(() => {
              checkConnectionsStatus();
            }, 2000);
          }
        }
      
        // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
        function handleSignal(from, data) {
          const pc = connections.get(from);
          
          if (!pc) {
            // å¦‚æœè¿æ¥ä¸å­˜åœ¨ï¼Œå…ˆåˆ›å»º
            createPeerConnection(from);
            setTimeout(() => handleSignal(from, data), 100);
            return;
          }
          
          if (data.sdp) {
            const desc = new RTCSessionDescription(data.sdp);
            pc.setRemoteDescription(desc).then(() => {
              if (desc.type === 'offer') {
                return pc.createAnswer().then(answer => {
                  pc.setLocalDescription(answer);
                  sendSignal(from, { sdp: answer });
                  
                  // è¿æ¥å»ºç«‹åæ›´æ–°çŠ¶æ€
                  pendingConnections.delete(from);
                  updateConnectionStatus();
                });
              } else if (desc.type === 'answer') {
                // å½“æ”¶åˆ°answeræ—¶ï¼Œè¿æ¥å»ºç«‹
                pendingConnections.delete(from);
                updateConnectionStatus();
              }
            }).catch(console.error);
          } else if (data.candidate) {
            pc.addIceCandidate(new RTCIceCandidate(data.candidate))
              .catch(console.error);
          }
        }
      
        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus() {
          if (pendingConnections.size === 0) {
            const otherMembers = Array.from(members).filter(id => id !== myId);
            if (otherMembers.length > 0) {
              updateStatus(`âœ… å·²å»ºç«‹æ‰€æœ‰P2Pè¿æ¥ (${otherMembers.length}ä¸ªè¿æ¥)`, 'success');
            }
          }
        }
      
        // å‘é€ä¿¡ä»¤æ¶ˆæ¯
        function sendSignal(target, data) {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
              type: 'signal',
              target: target,
              data: data
            }));
          }
        }
      
        // åˆ›å»ºå¯¹ç­‰è¿æ¥
        function createPeerConnection(peerId) {
          if (connections.has(peerId)) return connections.get(peerId);
          
          const pc = new RTCPeerConnection({
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:stun1.l.google.com:19302' }
            ]
          });
          
          connections.set(peerId, pc);
          
          // æ·»åŠ æœ¬åœ°è½¨é“
          if (myStream) {
            myStream.getTracks().forEach(track => {
              if (pc.getSenders().some(s => s.track === track)) return;
              pc.addTrack(track, myStream);
            });
          }
          
          // ICEå€™é€‰
          pc.onicecandidate = (e) => {
            if (e.candidate) {
              sendSignal(peerId, { candidate: e.candidate });
            }
          };
          
          // è¿œç¨‹è½¨é“
          pc.ontrack = (e) => {
            if (e.streams && e.streams[0]) {
              addRemoteVideo(peerId, e.streams[0]);
            }
          };
          
          // è¿æ¥çŠ¶æ€
          pc.onconnectionstatechange = () => {
            console.log(`è¿æ¥çŠ¶æ€ [${peerId}]: ${pc.connectionState}`);
            
            if (pc.connectionState === 'connected') {
              // è¿æ¥æˆåŠŸï¼Œä»ç­‰å¾…åˆ—è¡¨ä¸­ç§»é™¤
              pendingConnections.delete(peerId);
              updateConnectionStatus();
            } else if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
              // è¿æ¥å¤±è´¥ï¼Œå°è¯•é‡æ–°è¿æ¥
              setTimeout(() => {
                if (isInMeeting && members.has(peerId) && pc.connectionState !== 'connected') {
                  console.log(`å°è¯•é‡æ–°è¿æ¥ ${peerId}...`);
                  connections.delete(peerId);
                  createPeerConnection(peerId);
                }
              }, 3000);
            }
          };
          
          // å¦‚æœæ˜¯å‘èµ·æ–¹ï¼Œåˆ›å»ºoffer
          if (Array.from(members).indexOf(myId) < Array.from(members).indexOf(peerId)) {
            setTimeout(() => createOffer(peerId), 500);
          }
          
          return pc;
        }
      
        // åˆ›å»ºOffer
        function createOffer(peerId) {
          const pc = connections.get(peerId);
          if (!pc) return;
          
          pc.createOffer({
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          }).then(offer => {
            return pc.setLocalDescription(offer);
          }).then(() => {
            sendSignal(peerId, { sdp: pc.localDescription });
          }).catch(console.error);
        }
      
        // å»ºç«‹æ‰€æœ‰è¿æ¥
        function establishConnections() {
          const peerIds = Array.from(members).filter(id => 
            id !== myId && !connections.has(id)
          );
          
          peerIds.forEach(peerId => {
            createPeerConnection(peerId);
          });
        }
      
        // å…³é—­è¿æ¥
        function closeConnection(peerId) {
          const pc = connections.get(peerId);
          if (pc) {
            pc.close();
            connections.delete(peerId);
          }
          removeVideoElement(peerId);
          pendingConnections.delete(peerId);
        }
      
        // å¼€å¯/å…³é—­æ‘„åƒå¤´
        async function toggleCamera() {
          if (isCameraOn) {
            // å…³é—­æ‘„åƒå¤´
            myStream.getTracks().forEach(track => track.stop());
            myStream = null;
            isCameraOn = false;
            startCameraBtn.textContent = 'å¼€å¯æ‘„åƒå¤´';
            updateStatus('ğŸ“¹ æ‘„åƒå¤´å·²å…³é—­', 'info');
            clearVideos();
          } else {
            // å¼€å¯æ‘„åƒå¤´
            try {
              const constraints = {
                video: {
                  width: { ideal: 640 },
                  height: { ideal: 480 },
                  frameRate: { ideal: 20 }
                },
                audio: true
              };
              
              myStream = await navigator.mediaDevices.getUserMedia(constraints);
              isCameraOn = true;
              startCameraBtn.textContent = 'å…³é—­æ‘„åƒå¤´';
              updateStatus('ğŸ“¹ æ‘„åƒå¤´å·²å¼€å¯', 'success');
              addLocalVideo();
            } catch (err) {
              updateStatus(`âŒ å¼€å¯æ‘„åƒå¤´å¤±è´¥: ${err.message}`, 'error');
            }
          }
        }
      
        // åŠ å…¥ä¼šè®®
        function joinMeeting() {
          if (!isCameraOn) {
            updateStatus('è¯·å…ˆå¼€å¯æ‘„åƒå¤´', 'error');
            return;
          }
          
          if (ws && ws.readyState === WebSocket.OPEN) {
            isInMeeting = true;
            joinMeetingBtn.disabled = true;
            leaveMeetingBtn.disabled = false;
            meetingStatusElement.textContent = 'å·²åŠ å…¥';
            
            ws.send(JSON.stringify({ type: 'join' }));
            updateStatus('ğŸ¤ æ­£åœ¨åŠ å…¥ä¼šè®®...', 'info');
          }
        }
      
        // ç¦»å¼€ä¼šè®®
        function leaveMeeting() {
          isInMeeting = false;
          joinMeetingBtn.disabled = false;
          leaveMeetingBtn.disabled = true;
          meetingStatusElement.textContent = 'æœªåŠ å…¥';
          
          // æ¸…ç†è®¡æ—¶å™¨
          if (connectionCheckTimer) {
            clearTimeout(connectionCheckTimer);
            connectionCheckTimer = null;
          }
          
          // å…³é—­æ‰€æœ‰è¿æ¥
          connections.forEach((pc, id) => {
            pc.close();
            removeVideoElement(id);
          });
          connections.clear();
          pendingConnections.clear();
          
          // é€šçŸ¥æœåŠ¡å™¨
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'leave' }));
          }
          
          updateStatus('ğŸ‘‹ å·²ç¦»å¼€ä¼šè®®', 'info');
          members.clear();
          updateParticipantsUI();
        }
      
        // === UIç›¸å…³å‡½æ•° ===
        function updateStatus(text, type = 'info') {
          statusBar.textContent = text;
          statusBar.className = 'status-bar';
          
          if (type === 'error') {
            statusBar.classList.add('error');
          } else if (type === 'success') {
            // ä½¿ç”¨é»˜è®¤successæ ·å¼
          }
          
          // æ›´æ–°çŠ¶æ€æ–‡å­—é¢œè‰²
          statusBar.style.color = type === 'error' ? '#ffffff' : '#ffffff';
          statusBar.style.fontWeight = type === 'error' ? '600' : '500';
        }
      
        function updateParticipantsUI() {
          participantCount.textContent = members.size;
          participantList.innerHTML = '';
          
          members.forEach(id => {
            const item = document.createElement('div');
            item.className = id === myId ? 'participant-item current-participant' : 'participant-item';
            item.textContent = id === myId ? `æˆ‘ (${id})` : `å‚ä¸è€… (${id})`;
            participantList.appendChild(item);
          });
        }
      
        function addLocalVideo() {
          // å¦‚æœå·²æœ‰æœ¬åœ°è§†é¢‘ï¼Œå…ˆç§»é™¤
          const existing = document.getElementById('local-video');
          if (existing) existing.remove();
          
          const container = document.createElement('div');
          container.className = 'video-container';
          container.id = 'local-video';
          
          const video = document.createElement('video');
          video.autoplay = true;
          video.playsInline = true;
          video.muted = true;
          video.srcObject = myStream;
          
          const label = document.createElement('div');
          label.className = 'video-label';
          label.textContent = 'æˆ‘ (æœ¬åœ°)';
          
          container.appendChild(video);
          container.appendChild(label);
          videoGrid.appendChild(container);
        }
      
        function addRemoteVideo(peerId, stream) {
          // å¦‚æœå·²æœ‰è¯¥è¿œç¨‹è§†é¢‘ï¼Œå…ˆç§»é™¤
          removeVideoElement(peerId);
          
          const container = document.createElement('div');
          container.className = 'video-container';
          container.id = `video-${peerId}`;
          
          const video = document.createElement('video');
          video.autoplay = true;
          video.playsInline = true;
          video.srcObject = stream;
          
          const label = document.createElement('div');
          label.className = 'video-label';
          label.textContent = `å‚ä¸è€… (${peerId})`;
          
          container.appendChild(video);
          container.appendChild(label);
          videoGrid.appendChild(container);
        }
      
        function removeVideoElement(peerId) {
          const el = document.getElementById(`video-${peerId}`);
          if (el) el.remove();
        }
      
        function clearVideos() {
          videoGrid.innerHTML = '';
        }
      
        function resetState() {
          isCameraOn = false;
          isInMeeting = false;
          members.clear();
          
          if (connectionCheckTimer) {
            clearTimeout(connectionCheckTimer);
            connectionCheckTimer = null;
          }
          
          connections.forEach(pc => pc.close());
          connections.clear();
          pendingConnections.clear();
          clearVideos();
          
          startCameraBtn.disabled = true;
          joinMeetingBtn.disabled = true;
          leaveMeetingBtn.disabled = true;
          
          myIdElement.textContent = 'æœªè¿æ¥';
          meetingStatusElement.textContent = 'æœªåŠ å…¥';
          participantCount.textContent = '0';
          participantList.innerHTML = '';
        }
      
        // é¡µé¢åŠ è½½åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
          // è‡ªåŠ¨è¿æ¥æœ¬åœ°æœåŠ¡å™¨
          setTimeout(() => {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
              connectToServer();
            }
          }, 100);
        });
      </script>
</body>
</html>
